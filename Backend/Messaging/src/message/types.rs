use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};
use std::collections::HashMap;

/// Core message types that the broker handles
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum MessageType {
    /// Encrypted text message
    TextMessage,
    /// Encrypted group message
    GroupMessage,
    /// Media message (metadata only)
    MediaMessage,
    /// Presence update
    Presence,
    /// Typing indicator
    Typing,
    /// Message delivered receipt
    Delivered,
    /// Message read receipt
    Read,
    /// Acknowledgement
    Ack,
    /// Error response
    Error,
}

/// Base message envelope - THE BROKER ONLY SEES THIS
/// Payload is treated as opaque encrypted bytes
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageEnvelope {
    /// Message type
    pub message_type: MessageType,
    
    /// Sender user ID
    pub from: String,
    
    /// Recipient(s) - either single user ID or group ID
    /// For group messages, this is the group ID
    pub to: Vec<String>,
    
    /// Opaque encrypted payload - broker NEVER decrypts this
    /// For media messages, this contains metadata only (URLs, not content)
    pub payload: EncryptedPayload,
    
    /// Unique message ID (generated by gateway or broker)
    pub message_id: String,
    
    /// Timestamp in milliseconds
    pub timestamp: i64,
    
    /// Optional metadata for routing
    pub metadata: HashMap<String, String>,
}

/// Encrypted payload - treated as opaque bytes by broker
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EncryptedPayload {
    /// Base64 encoded ciphertext
    /// For E2EE text messages: encrypted message content
    /// For media messages: encrypted JSON with metadata
    pub ciphertext: String,
    
    /// Optional initialization vector
    pub iv: Option<String>,
    
    /// Optional authentication tag
    pub tag: Option<String>,
    
    /// Optional key ID for future key rotation
    pub key_id: Option<String>,
}

/// Media metadata (encrypted in payload for E2EE, or plain for non-E2EE)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MediaMetadata {
    /// Media type
    pub media_type: MediaType,
    
    /// Secure URL to media object (S3/MinIO)
    pub url: String,
    
    /// Optional thumbnail URL
    pub thumbnail_url: Option<String>,
    
    /// File size in bytes
    pub size_bytes: u64,
    
    /// MIME type
    pub mime_type: String,
    
    /// Media dimensions (for images/video)
    pub width: Option<u32>,
    pub height: Option<u32>,
    
    /// Duration in seconds (for audio/video)
    pub duration_seconds: Option<f32>,
    
    /// Optional filename
    pub filename: Option<String>,
    
    /// Optional caption (encrypted if E2EE)
    pub caption: Option<String>,
}

/// Supported media types
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum MediaType {
    Image,
    Video,
    Gif,
    Audio,
    File,
    Sticker,
}

/// Presence update
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PresenceUpdate {
    pub user_id: String,
    pub status: PresenceStatus,
    pub device_id: String,
    pub last_seen: i64,
    pub platform: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum PresenceStatus {
    Online,
    Away,
    Offline,
    DoNotDisturb,
}

/// Typing indicator
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TypingIndicator {
    pub user_id: String,
    pub chat_id: String,
    pub is_typing: bool,
}

/// Delivery receipt
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeliveryReceipt {
    pub message_id: String,
    pub recipient_id: String,
    pub timestamp: i64,
    pub device_id: Option<String>,
}

/// Read receipt
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReadReceipt {
    pub message_id: String,
    pub reader_id: String,
    pub timestamp: i64,
    pub device_id: Option<String>,
}

/// Acknowledgement
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Acknowledgement {
    pub original_message_id: String,
    pub status: AckStatus,
    pub timestamp: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum AckStatus {
    Delivered,
    Read,
    Failed,
}

/// Error response
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ErrorResponse {
    pub code: String,
    pub message: String,
    pub details: Option<String>,
}

impl MessageEnvelope {
    /// Create a new message envelope with current timestamp
    pub fn new(
        message_type: MessageType,
        from: String,
        to: Vec<String>,
        payload: EncryptedPayload,
    ) -> Self {
        Self {
            message_type,
            from,
            to,
            payload,
            message_id: Uuid::new_v4().to_string(),
            timestamp: Utc::now().timestamp_millis(),
            metadata: HashMap::new(),
        }
    }
    
    /// Validate the message envelope
    pub fn validate(&self, limits: &crate::config::RateLimits) -> Result<(), ValidationError> {
        // Check message size
        let serialized = serde_json::to_vec(self).map_err(|_| ValidationError::SerializationError)?;
        if serialized.len() > limits.max_message_size {
            return Err(ValidationError::MessageTooLarge);
        }
        
        // Check recipient count
        if self.to.len() > limits.max_recipients_per_message {
            return Err(ValidationError::TooManyRecipients);
        }
        
        // Validate user IDs
        if !is_valid_user_id(&self.from) {
            return Err(ValidationError::InvalidSender);
        }
        
        for recipient in &self.to {
            if !is_valid_user_id(recipient) && !is_valid_group_id(recipient) {
                return Err(ValidationError::InvalidRecipient);
            }
        }
        
        // Validate payload size (encrypted payload should be reasonable)
        if self.payload.ciphertext.len() > 1024 * 1024 { // 1MB max for ciphertext
            return Err(ValidationError::PayloadTooLarge);
        }
        
        Ok(())
    }
    
    /// Check if this is a group message
    pub fn is_group_message(&self) -> bool {
        self.message_type == MessageType::GroupMessage
    }
    
    /// Get group ID if this is a group message
    pub fn group_id(&self) -> Option<&str> {
        if self.is_group_message() && !self.to.is_empty() {
            Some(&self.to[0])
        } else {
            None
        }
    }
}

fn is_valid_user_id(id: &str) -> bool {
    // Simple validation - in production use proper regex
    !id.is_empty() && id.len() <= 64 && !id.contains(' ')
}

fn is_valid_group_id(id: &str) -> bool {
    id.starts_with("group_") && is_valid_user_id(&id[6..])
}

#[derive(Debug, thiserror::Error)]
pub enum ValidationError {
    #[error("message too large")]
    MessageTooLarge,
    #[error("too many recipients")]
    TooManyRecipients,
    #[error("invalid sender ID")]
    InvalidSender,
    #[error("invalid recipient ID")]
    InvalidRecipient,
    #[error("payload too large")]
    PayloadTooLarge,
    #[error("serialization error")]
    SerializationError,
}
